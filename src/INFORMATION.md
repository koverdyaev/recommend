## Коротко о проекте

Шаблон проекта создан при помощи django-cookiecutter чтобы следовать django best practices и для ускорения разработки.

Из-за  это есть некоторые особенности:
1) Настройки и зависимости вынесены в отдельные пакеты config и requirements. Это позволяет проще разделять локальное и продакшен окружения.
2) В настройках используется env для получения креденшиалов из переменных окружения, что позволяет хранить боевые настройки в репозитории, заменяя лишь ".env" файл.


Проект использует:
* python 3.5
* postgres
* redis
* для выкладки предполагается использование docker, но это еще не доделано.

Наиболее популярными и => лучше поддерживаемыми базами для django являются Postgres и MySQL.
Postgres выбрал из-за того, что:
* лучше документация
* поддерживает транзакции и вообще в нем больше возможностей
* лучше поддреживает стандарты
* вроде как с него проще мигрировать на NoSQL, если возникнет такая нужда

основные библитоеки Python
* djangorestframework  для построенния API
* celery для выполнения отложенных задач и задач по расписанию
* sentry для логирования ошибок на проде


Проект состоит из следующих приложений:

1) **users** 

Приложение с переопределенной моделью пользователя. Это сделано для добавления к модели трэков и последующего расширения, которое наверняка потребуется.
После запуска проекта изменить пользовательскую модель значительно труднее.

2) **recomendation_storage**

Приложение для хранения результатов вычислений. На данный момент ML в проекте не используется, но оно явно тут будет нужно. чтобы не заставлять пользователя ждать результатов расчета,
лучше вычислить рекомендуемые треки заранее. Хранение результатов предполагается в redis из-за его высокой скорости. К тому же есть статьи о том, как хранить действительно большое количество данных 
в редисе и не занимать при этом много места в памяти. Обновлять таблицы можно по расписанию используя celery, настраивая частоту обновления под загрузку сервиса.
Как уже отмечено ML не используется и единственная рабочая таблица заполняется на основе пользовательской библиотеки и выдает рекомендации на используя следующий алгоритм:
* Выбрать пользователй у которых больше всего совпадающих треков с пользователем
* Посчитать количество вхождений каждого трека не содержащегося в исходной библиотеке, в библиотеки этих "похожих" пользователей
* Вернуть наиболее популярные, т.е. с наибольшим коичеством вхождений
Возможно, для подобных вычислений не нужна закешированная таблица и можно будет обойтись настройкой нескольких реплик базы, но без тестов сказать трудно.

3) **data_providers**

Хранилище соответствий пользователей аккаунтам на сторонних сервисах. Возможно лучше сделать базовый класс провайдера с одинаковым API для дочерних классов, но я не успел.
Здесь реализован провайдер для LastFM. Есть библиотека для интеграции с АПИ lastfm для питона - pylast, однако она не поддерживает пагинацию и с ее помощью нельзя получить свыше 1000 треков поользователя.

4) **taskapp**

Celery для отложенных вычислений и запуска задач по расписанию. Запускает получение пользовательской библиотеки из LastFM, предполагается перерасчет таблиц рекомендаций.

5) **api**

API на базе DRF. Предполагается использование токена для авторизации пользователей.


Запуск проекта предполагается при помощи docker + docker-compose. django-cookiecutter сразу создает все нужное для такого запуска, однако для этого проекта нужно доделать настройки.
Я пока не успел этого сделать.

Сейчас для того, чтобы запустить проект нужно
установить в систему Postgres и Redis
склонировать проект git clone ... project
cd project
virtualenv -p python3 venv
source venv/bin/activate
pip install -r src/requrements/local.txt
./manage.py runserver


Что еще нужно сделать:
* добавить регистрацию/логин в API
* Юобавить пагинацию во все вьюшки которые возврщают списки
* Заменить набор пользовательских вьюшек одним вьюсетом
* Возвращать id задачи на добавление пользовательской библиотеки для проверки статуса
* Добавить вьюшку для проверки статуса выполнения задач в  celery
* Добавить задачи по расписанию для обновления таблиц
* Получение тэгов альбомов и т.д. из ласт фм. На полчении треков они не возвращаются, их нужно запрашивать отдельно.
* Добавить задачи по расписанию на получение топ тэгов, жанров -> артистов -> треков
* Настроить реплики для постргреса
* Написать тесты когда реализация более-менее установится 

